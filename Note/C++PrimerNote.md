# C++ Primer Note

*开始时间: 9月4号*

## Sec1 Begin

## Sec2 Basic Built-in Type

### 2.1 基本内置类型

* 符号数:
    * 无符号数和负数相加。会先将负数转化为无符号数再进行相加
    * 无符号数相减，无论如何都不可能为负数，若结果为负数，则会直接按照比特位来读取无符号数
    * 混用无符号和有符号型，比如相乘，得看机器上int所占位数而定
* 转义序列（escape sequence） 
    * \\ 后面跟3个字符。都是转义的内容 
        * 例子：\\1234，表示转义字符\\123和字符4
* 0开头的数为8进制数。以0X开头的为16进制数
* 表示浮点数：
    * 反例：`1024f`。正确应该为`1024.f`

### 2.2 变量

* 初始化

  * 列表初始化

    ```
    long double ld = 3.14159   
    int a{ld}, b = {ld};	// 报错，存在丢失信息风险
    int a(ld), b = ld;    	// 正确，但丢失部分值
    ```

  * 默认初始化
    没有指定初值，默认初始化

    * 定义于任何函数之外的变量被初始化为0
    * 定义在函数体内部的内置类型变量将不被初始化 uninitialized
    * 每个类各自决定初始化对象的方式
      是否不经过初始化就定义对象也由类自己决定
    * 建议初始化每一个内置类型的变量

  * 声明和定义：
    变量声明规定了变量的类型和名字，定义也一样，不同点在于，定义还申请存储空间，也可能会给变量赋一个初始值
    任何包含显示初始化的声明，即成为定义

    ```
    extern int i;	// 声明i，并非定义i
    int j;			// 声明并定义j
    extern double pi = 3.14 // 定义
    ```

    函数内部，如果试图初始化一个由extern关键字标记的变量会引发错误
    变量能且只能被定义一次，但可以被多次声明

  * 作用域
    scope

  ### 2.3 复合类型 (Compound Type)

  * 引用：reference

    * lvalue reference
      一般指：左值引用 \&
  
      一定要初始化！定义引用时，程序把引用与他的初始值bind绑定在一起，而不是将初始值拷贝给引用。
      一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定另外一个对象，因此引用必须初始化。
      （引用只是为一个已经存在的变量起一个别名）
  
  * 指针 pointer
  
    \&：取地址符
    \*：解引用符
  
    * 空指针：
      nullptr可以转化为任意其他的指针类型
  
      ```
      int *p1 = nullptr; // 建议
      int *p2 = 0;
      int *p3 = NULL; // (预处理变量（preprocessor variable）)
      ```
  
    * void\* 指针 
      不能直接操作，因为我们不知道是什么类型
  
    * 指向指针的引用：（不能定义指向引用的指针，因为引用不是对象）
      ```
      int i  = 42;
      int *p;
      int *&r = p; // r是一个对指针p的引用，从右往左看
      
      r = &i;  // r引用了一个指针，因此给r赋值给&i, 就是令p指向i
      ```
  
  ### 2.4 const限定符
  
  * const对象必须初始化
  
  * 多文件使用同一个const？
    每个文件都用  `extern const int bufSize`  // 例子,都加extern
  
  * **const的引用**
    (reference to const)
  
    ```
    const int ci = 1024;
    const int &r1 = ci; 	// 引用及其对应的对象都是常量
    r1 = 42; 	// 错误
    int &r2 = ci;	// 错误。让一个非常量引用指向一个常量对象
    ```
  
    ```
    int i = 42;
    const int &r1 = i; 	// 正确，常量引用
    const int &r3 = r1*2;	// 正确，常量引用
    int &r4 = r1 * 2;	// 错误，r4是一个普通的非常量引用
    ```
  
    

